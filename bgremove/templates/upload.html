{% extends "layout.html" %}

{% block title %}Remove Background - CroPix{% endblock %}

{%block extra_head %}
<style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; padding: 24px; background: #f6f7fb; color: #111; }
    .card { max-width: 900px; margin: 0 auto; background: #fff; border-radius: 12px; box-shadow: 0 10px 30px rgba(0,0,0,0.06); padding: 24px; }
    h1 { font-size: 22px; margin: 0 0 16px; }
    .responsive-grid {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 32px;
        align-items: start;
    }
    @media (max-width: 800px) {
        .responsive-grid {
            grid-template-columns: 1fr;
        }
    }
    .upload-btn { display: flex; justify-content: center; align-items: center; margin-bottom: 24px; position: relative; }
    .upload-btn input[type="file"] { display: none; }
    .upload-btn label { background: #2563eb; color: white; border-radius: 8px; padding: 14px 32px; font-weight: 600; cursor: pointer; font-size: 16px; transition: background 0.2s; }
    .upload-btn label:hover { background: #1d4ed8; }
    .canvas-wrap { position: relative; width: 100%; background: #eef2ff; border-radius: 8px; overflow: hidden; min-height: 320px; display: flex; align-items: center; justify-content: center; }
    canvas { width: 100%; height: auto; display: block; background: #f8fafc; }
    .legend { font-size: 12px; color: #374151; margin-top: 12px; }
    .toolbar { display: flex; gap: 10px; align-items: center; flex-wrap: wrap; }
    .swatch { width: 28px; height: 28px; border-radius: 50%; border: 2px solid #111; cursor: pointer; display: inline-flex; align-items: center; justify-content: center; font-size: 12px; color: #111; }
    .swatch.selected { outline: 3px solid #111; }
    .field { margin: 16px 0; }
    .hidden { display: none; }
    .download-row {
        display: flex;
        gap: 0;
        align-items: center;
        margin-bottom: 24px;
        margin-top: 0;
        flex-wrap: wrap;
        width: 100%;
        justify-content: flex-start;
    }
    #downloadBtn {
        background: #2563eb;
        color: white;
        border: none;
        border-radius: 8px 0 0 8px;
        padding: 10px 24px;
        font-weight: 600;
        cursor: pointer;
        font-size: 16px;
        transition: background 0.2s;
        margin-right: -1px;
        z-index: 2;
    }
    #downloadBtn:disabled {
        background: #a5b4fc;
        cursor: not-allowed;
    }
    #formatSelect, #resolutionSelect {
        padding: 10px 18px;
        border: none;
        font-size: 16px;
        font-weight: 600;
        background: #2563eb;
        color: white;
        z-index: 1;
    }
    #formatSelect {
        border-radius: 0;
    }
    #resolutionSelect {
        border-radius: 0 8px 8px 0;
    }
    .download-row > * {
        box-shadow: 0 2px 8px #0001;
    }
</style>
{% endblock %}

{% block content %}
<div class="card">
    <h1>Procesar imagen (API)</h1>
    <form id="form" method="post" enctype="multipart/form-data">
        {% csrf_token %}
        <div class="responsive-grid">
            <div>
                <div class="upload-btn" id="uploadBtnWrap">
                    <input id="image" type="file" name="image" accept="image/*" required>
                    <label for="image" id="uploadLabel">Subir imagen</label>
                </div>
                <div class="canvas-wrap">
                    <canvas id="canvas"></canvas>
                </div>
                <div class="legend">Pincel guía (escala de grises): blanco=255 sujeto (conservar), negro=0 fondo (quitar), gris=128 desconocido.</div>
            </div>
            <div>
                <div class="download-row">
                    <button type="button" id="downloadBtn" disabled>Descargar</button>
                    <select id="formatSelect">
                        <option value="png">PNG</option>
                        <option value="webp">WebP</option>
                        <option value="svg">SVG</option>
                    </select>
                    <select id="resolutionSelect">
                        <option value="1">1x</option>
                        <option value="2">2x</option>
                        <option value="4">4x</option>
                        <option value="8">8x</option>
                    </select>
                </div>
                <div class="field">
                    <label>Herramientas</label>
                    <div class="toolbar">
                        <div class="swatch selected" data-color="keep" title="Sujeto" style="background:#ffffff">S</div>
                        <div class="swatch" data-color="remove" title="Fondo" style="background:#000000; color:#fff;">F</div>
                        <div class="swatch" data-color="unknown" title="Desconocido" style="background:#9ca3af">?</div>
                        <label style="margin-left:10px;">Grosor
                            <input id="size" type="range" min="5" max="80" value="24">
                        </label>
                        <button type="button" id="clear" style="background:#6b7280">Limpiar</button>
                    </div>
                </div>
            </div>
        </div>
        <input type="hidden" name="mask_data" id="mask_data">
        <input type="hidden" name="mode" value="keep_subject">
    </form>
    <div id="status" class="hint" style="margin-top:12px;"></div>
</div>

<script>
const fileInput = document.getElementById('image');
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const maskField = document.getElementById('mask_data');
const statusEl = document.getElementById('status');
const uploadBtnWrap = document.getElementById('uploadBtnWrap');
const downloadBtn = document.getElementById('downloadBtn');
const formatSelect = document.getElementById('formatSelect');
const resolutionSelect = document.getElementById('resolutionSelect');

const drawLayer = document.createElement('canvas');
const drawCtx = drawLayer.getContext('2d');

const sizeInput = document.getElementById('size');
const clearBtn = document.getElementById('clear');

let brush = 'keep';
let drawing = false;
let imgBitmap = null;
let dirty = false;
let lastResultDataUrl = null;
let lastResultImg = null;

function setCanvasSize(w, h) {
    canvas.width = w;
    canvas.height = h;
    drawLayer.width = w;
    drawLayer.height = h;
    drawCtx.fillStyle = 'rgb(128,128,128)';
    drawCtx.fillRect(0, 0, w, h);
    dirty = false;
    render();
}

function render() {
    if (!imgBitmap) return;
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.drawImage(imgBitmap, 0, 0, canvas.width, canvas.height);
    ctx.globalAlpha = 0.35;
    ctx.drawImage(drawLayer, 0, 0);
    ctx.globalAlpha = 1;
}

function valueForBrush() {
    if (brush === 'keep') return 255;
    if (brush === 'remove') return 0;
    return 128;
}

function drawDot(x, y, r) {
    const v = valueForBrush();
    drawCtx.fillStyle = `rgb(${v},${v},${v})`;
    drawCtx.beginPath();
    drawCtx.arc(x, y, r, 0, Math.PI * 2);
    drawCtx.fill();
    dirty = true;
}

function getPos(e) {
    const rect = canvas.getBoundingClientRect();
    const x = (e.touches ? e.touches[0].clientX : e.clientX) - rect.left;
    const y = (e.touches ? e.touches[0].clientY : e.clientY) - rect.top;
    return { x: x * (canvas.width / rect.width), y: y * (canvas.height / rect.height) };
}

canvas.addEventListener('mousedown', (e) => { drawing = true; const p = getPos(e); drawDot(p.x, p.y, +sizeInput.value/2); render(); });
canvas.addEventListener('touchstart', (e) => { drawing = true; const p = getPos(e); drawDot(p.x, p.y, +sizeInput.value/2); render(); e.preventDefault(); }, { passive: false });
window.addEventListener('mouseup', () => drawing = false);
window.addEventListener('touchend', () => drawing = false);
canvas.addEventListener('mousemove', (e) => { if (!drawing) return; const p = getPos(e); drawDot(p.x, p.y, +sizeInput.value/2); render(); });
canvas.addEventListener('touchmove', (e) => { if (!drawing) return; const p = getPos(e); drawDot(p.x, p.y, +sizeInput.value/2); render(); e.preventDefault(); }, { passive: false });

document.querySelectorAll('.swatch').forEach(el => {
    el.addEventListener('click', () => {
        document.querySelectorAll('.swatch').forEach(s => s.classList.remove('selected'));
        el.classList.add('selected');
        brush = el.dataset.color;
    });
});

clearBtn.addEventListener('click', () => {
    drawCtx.fillStyle = 'rgb(128,128,128)';
    drawCtx.fillRect(0, 0, drawLayer.width, drawLayer.height);
    dirty = false;
    render();
});

fileInput.addEventListener('change', async (e) => {
    const file = e.target.files[0];
    if (!file) return;
    imgBitmap = await createImageBitmap(file);
    setCanvasSize(imgBitmap.width, imgBitmap.height);
    render();
    uploadBtnWrap.style.display = 'none';
    statusEl.textContent = 'Procesando...';
    let maskData = '';
    if (dirty) {
        maskData = drawLayer.toDataURL('image/png');
    }
    const fd = new FormData();
    fd.append('csrfmiddlewaretoken', document.querySelector('[name=csrfmiddlewaretoken]').value);
    fd.append('image', file);
    fd.append('mask_data', maskData);
    fd.append('mode', 'keep_subject');
    try {
        const resp = await fetch('/api/remove/', {
            method: 'POST',
            headers: {
                'X-CSRFToken': fd.get('csrfmiddlewaretoken')
            },
            body: fd
        });
        const data = await resp.json();
        if(!data.success){
            statusEl.textContent = 'Error: ' + (data.error || 'desconocido');
            downloadBtn.disabled = true;
        } else {
            statusEl.textContent = 'Listo.';
            lastResultDataUrl = data.image_data;
            drawResultOnCanvas(data.image_data);
            downloadBtn.disabled = false;
        }
    } catch(err){
        statusEl.textContent = 'Error de red.';
        downloadBtn.disabled = true;
    }
});

function drawResultOnCanvas(dataURL){
    const img = new Image();
    img.onload = () => {
        lastResultImg = img;
        const w = img.width, h = img.height;
        canvas.width = w; canvas.height = h;
        ctx.clearRect(0, 0, w, h);
        ctx.drawImage(img,0,0);
    };
    img.src = dataURL;
}

// Descargar imagen procesada en formato y resolución seleccionados
downloadBtn.addEventListener('click', () => {
    if (!lastResultDataUrl || !lastResultImg) return;
    const format = formatSelect.value;
    const scale = parseInt(resolutionSelect.value, 10) || 1;
    const w = lastResultImg.width * scale;
    const h = lastResultImg.height * scale;

    // Crear canvas temporal para exportar en la resolución deseada
    const exportCanvas = document.createElement('canvas');
    exportCanvas.width = w;
    exportCanvas.height = h;
    const exportCtx = exportCanvas.getContext('2d');
    exportCtx.clearRect(0, 0, w, h);
    exportCtx.drawImage(lastResultImg, 0, 0, w, h);

    if (format === 'png') {
        exportCanvas.toBlob(function(blob) {
            const url = URL.createObjectURL(blob);
            downloadBlob(url, `imagen-procesada-${scale}x.png`);
        }, 'image/png');
    } else if (format === 'webp') {
        exportCanvas.toBlob(function(blob) {
            const url = URL.createObjectURL(blob);
            downloadBlob(url, `imagen-procesada-${scale}x.webp`);
        }, 'image/webp');
    } else if (format === 'svg') {
        // Rasteriza como PNG embebido en SVG
        const dataURL = exportCanvas.toDataURL('image/png');
        const svg = `<svg xmlns="http://www.w3.org/2000/svg" width="${w}" height="${h}">
            <image href="${dataURL}" width="${w}" height="${h}"/>
        </svg>`;
        const blob = new Blob([svg], {type: 'image/svg+xml'});
        const url = URL.createObjectURL(blob);
        downloadBlob(url, `imagen-procesada-${scale}x.svg`);
    }
});

function downloadBlob(url, filename) {
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    setTimeout(() => URL.revokeObjectURL(url), 1000);
    document.body.removeChild(a);
}
</script>
{% endblock %}
